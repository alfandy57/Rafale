package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"math/big"
	"strconv"
	"time"

	"github.com/0xredeth/Rafale/internal/api/graphql/generated"
	"github.com/0xredeth/Rafale/internal/api/graphql/model"
	"github.com/0xredeth/Rafale/internal/store"
)

// SyncStatus is the resolver for the syncStatus field.
func (r *queryResolver) SyncStatus(ctx context.Context) (*model.SyncStatus, error) {
	// Get current chain head
	headBlock, err := r.RPC.BlockNumber(ctx)
	if err != nil {
		return nil, fmt.Errorf("getting head block: %w", err)
	}

	// For now, return a basic status (can be enhanced with DB query for indexed block)
	currentBlock := headBlock // TODO: Get from indexed state
	lag := headBlock - currentBlock

	return &model.SyncStatus{
		Network:      r.Config.Network,
		ChainID:      strconv.FormatUint(r.Config.ChainID, 10),
		CurrentBlock: strconv.FormatUint(currentBlock, 10),
		HeadBlock:    strconv.FormatUint(headBlock, 10),
		Lag:          strconv.FormatUint(lag, 10),
		IsSynced:     lag == 0,
		LastSyncTime: nil,
	}, nil
}

// Block is the resolver for the block field.
func (r *queryResolver) Block(ctx context.Context, number string) (*model.Block, error) {
	blockNum, ok := new(big.Int).SetString(number, 10)
	if !ok {
		return nil, fmt.Errorf("invalid block number: %s", number)
	}

	header, err := r.RPC.HeaderByNumber(ctx, blockNum)
	if err != nil {
		return nil, fmt.Errorf("getting block: %w", err)
	}

	if header == nil {
		return nil, nil
	}

	return &model.Block{
		Number:     strconv.FormatUint(header.Number.Uint64(), 10),
		Hash:       header.Hash().Hex(),
		Timestamp:  time.Unix(int64(header.Time), 0),
		ParentHash: header.ParentHash.Hex(),
	}, nil
}

// LatestBlock is the resolver for the latestBlock field.
func (r *queryResolver) LatestBlock(ctx context.Context) (*model.Block, error) {
	blockNum, err := r.RPC.BlockNumber(ctx)
	if err != nil {
		return nil, fmt.Errorf("getting block number: %w", err)
	}

	return r.Block(ctx, strconv.FormatUint(blockNum, 10))
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, filter *model.EventFilter, orderBy *model.EventOrder, first *int, after *string, last *int, before *string) (*model.EventConnection, error) {
	// Build query parameters for generic events table
	q := store.EventQuery{}

	// Apply filters
	if filter != nil {
		if filter.Contract != nil {
			q.ContractName = filter.Contract
		}
		if filter.EventName != nil {
			q.EventName = filter.EventName
		}
		if filter.FromBlock != nil {
			block, err := strconv.ParseUint(*filter.FromBlock, 10, 64)
			if err != nil {
				return nil, fmt.Errorf("invalid fromBlock: %w", err)
			}
			q.FromBlock = &block
		}
		if filter.ToBlock != nil {
			block, err := strconv.ParseUint(*filter.ToBlock, 10, 64)
			if err != nil {
				return nil, fmt.Errorf("invalid toBlock: %w", err)
			}
			q.ToBlock = &block
		}
		if filter.FromTime != nil {
			q.FromTime = filter.FromTime
		}
		if filter.ToTime != nil {
			q.ToTime = filter.ToTime
		}
	}

	// Apply ordering
	if orderBy != nil {
		switch orderBy.Field {
		case model.EventOrderFieldBlockNumber:
			q.OrderBy = "block_number"
		case model.EventOrderFieldTimestamp:
			q.OrderBy = "timestamp"
		}
		q.OrderDir = string(orderBy.Direction)
	} else {
		q.OrderBy = "block_number"
		q.OrderDir = "ASC"
	}

	// Apply pagination
	limit := 20 // default
	if first != nil && *first > 0 {
		limit = *first
	}
	if last != nil && *last > 0 {
		limit = *last
	}
	// Cap at 100 for safety
	if limit > 100 {
		limit = 100
	}
	q.Limit = limit + 1 // fetch one extra to determine hasNextPage

	// Parse cursor
	if after != nil {
		id, err := decodeCursor(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid after cursor: %w", err)
		}
		q.AfterID = &id
	}
	if before != nil {
		id, err := decodeCursor(*before)
		if err != nil {
			return nil, fmt.Errorf("invalid before cursor: %w", err)
		}
		q.BeforeID = &id
	}

	// Execute query against generic events table
	events, totalCount, err := r.Store.QueryEvents(ctx, q)
	if err != nil {
		return nil, fmt.Errorf("querying events: %w", err)
	}

	// Determine pagination info
	hasNextPage := len(events) > limit
	if hasNextPage {
		events = events[:limit] // trim extra
	}
	hasPreviousPage := after != nil

	// Build edges
	edges := make([]*model.EventEdge, len(events))
	for i, e := range events {
		event := eventToGenericEvent(&e)
		edges[i] = &model.EventEdge{
			Cursor: encodeCursor(e.ID),
			Node:   event,
		}
	}

	// Build page info
	var startCursor, endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &model.EventConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: int(totalCount),
	}, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*model.GenericEvent, error) {
	// Parse ID
	eventID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid event id: %w", err)
	}

	event, err := r.Store.GetEventByID(ctx, eventID)
	if err != nil {
		return nil, fmt.Errorf("getting event: %w", err)
	}
	if event == nil {
		return nil, nil
	}

	return eventToGenericEvent(event), nil
}

// EventsByTx is the resolver for the eventsByTx field.
func (r *queryResolver) EventsByTx(ctx context.Context, txHash string) ([]*model.GenericEvent, error) {
	events, err := r.Store.GetEventsByTxHash(ctx, txHash)
	if err != nil {
		return nil, fmt.Errorf("getting events by tx: %w", err)
	}

	result := make([]*model.GenericEvent, len(events))
	for i, e := range events {
		result[i] = eventToGenericEvent(&e)
	}
	return result, nil
}

// NewEvent is the resolver for the newEvent field.
func (r *subscriptionResolver) NewEvent(ctx context.Context, contract *string, eventName *string) (<-chan *model.GenericEvent, error) {
	// TODO: Implement event subscription with pubsub
	ch := make(chan *model.GenericEvent)
	go func() {
		<-ctx.Done()
		close(ch)
	}()
	return ch, nil
}

// NewBlock is the resolver for the newBlock field.
func (r *subscriptionResolver) NewBlock(ctx context.Context) (<-chan *model.Block, error) {
	// TODO: Implement block subscription
	ch := make(chan *model.Block)
	go func() {
		<-ctx.Done()
		close(ch)
	}()
	return ch, nil
}

// SyncStatusUpdated is the resolver for the syncStatusUpdated field.
func (r *subscriptionResolver) SyncStatusUpdated(ctx context.Context) (<-chan *model.SyncStatus, error) {
	// TODO: Implement sync status subscription
	ch := make(chan *model.SyncStatus)
	go func() {
		<-ctx.Done()
		close(ch)
	}()
	return ch, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// Helper functions for cursor-based pagination and type conversion.

// encodeCursor encodes a transfer ID into a cursor string.
func encodeCursor(id uint64) string {
	return base64.StdEncoding.EncodeToString([]byte(strconv.FormatUint(id, 10)))
}

// decodeCursor decodes a cursor string into a transfer ID.
func decodeCursor(cursor string) (uint64, error) {
	decoded, err := base64.StdEncoding.DecodeString(cursor)
	if err != nil {
		return 0, fmt.Errorf("decoding cursor: %w", err)
	}
	id, err := strconv.ParseUint(string(decoded), 10, 64)
	if err != nil {
		return 0, fmt.Errorf("parsing cursor id: %w", err)
	}
	return id, nil
}

// eventToGenericEvent converts a store.Event to a model.GenericEvent.
func eventToGenericEvent(e *store.Event) *model.GenericEvent {
	// Parse JSONB data into map
	var data map[string]any
	if err := json.Unmarshal(e.Data, &data); err != nil {
		data = map[string]any{"raw": string(e.Data)}
	}

	return &model.GenericEvent{
		ID:          strconv.FormatUint(e.ID, 10),
		BlockNumber: strconv.FormatUint(e.BlockNumber, 10),
		TxHash:      e.TxHash,
		TxIndex:     int(e.TxIndex),
		LogIndex:    int(e.LogIndex),
		Timestamp:   e.Timestamp,
		Contract:    e.ContractName,
		EventName:   e.EventName,
		Data:        data,
	}
}
