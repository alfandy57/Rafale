// Code generated by rafale codegen. DO NOT EDIT.
// Source: {{.ContractName}} contract ABI - {{.EventName}} event
//
// TYPED HANDLER (OPTIONAL)
// --------------------------
// All decoded events are automatically stored in the generic 'events' table
// with JSONB data. This typed handler is OPTIONAL and provides:
//
//   - Typed table with indexed columns for faster queries
//   - Strong typing for event fields
//   - Custom query optimization (e.g., index on 'from', 'to' addresses)
//
// To disable this typed handler:
//   - Remove the import from cmd/rafale/cli/start.go
//   - Or delete this generated file
//
// The generic events table will still capture all {{.EventName}} events.

package {{.PackageName}}

import (
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"

	"github.com/0xredeth/Rafale/internal/store"
	"github.com/0xredeth/Rafale/pkg/handler"
)

// Ensure imports are used
var (
	_ = big.NewInt
	_ = common.Address{}
)

// {{.StructName}} represents a {{.EventName}} event from the {{.ContractName}} contract.
// This typed model is OPTIONAL - all events are also stored in the generic 'events' table.
// Use this typed table when you need indexed queries on specific fields.
type {{.StructName}} struct {
	store.BaseEvent
{{range .Fields}}
	// {{.GoName}} is the {{.Name}} field ({{.SolidityType}}).
	{{.GoName}} {{.GoType}} `json:"{{.JSONTag}}" gorm:"{{.GormTag}}"`
{{end}}}

// TableName returns the database table name for {{.StructName}}.
func ({{.StructName}}) TableName() string {
	return "{{.TableName}}"
}

// EventID returns the event identifier for handler registration.
func ({{.StructName}}) EventID() string {
	return "{{.EventID}}"
}

func init() {
	handler.Register("{{.EventID}}", handle{{.StructName}})
}

// handle{{.StructName}} processes {{.EventName}} events into the typed table.
// This handler is OPTIONAL - events are always stored in the generic 'events' table.
func handle{{.StructName}}(ctx *handler.Context) error {
	event := &{{.StructName}}{
		BaseEvent: store.BaseEvent{
			BlockNumber: ctx.Block.Number,
			TxHash:      ctx.Log.TxHash.Hex(),
			TxIndex:     ctx.Log.TxIndex,
			LogIndex:    ctx.Log.Index,
			Timestamp:   ctx.Block.Time,
		},
	}

	// Extract indexed fields from topics
{{range $i, $f := .IndexedFields}}	if len(ctx.Log.Topics) > {{add $i 1}} {
{{if eq $f.SolidityType "address"}}		event.{{$f.GoName}} = common.HexToAddress(ctx.Log.Topics[{{add $i 1}}].Hex()).Hex()
{{else if isBigInt $f.SolidityType}}		event.{{$f.GoName}} = ctx.Log.Topics[{{add $i 1}}].Big().String()
{{else}}		event.{{$f.GoName}} = ctx.Log.Topics[{{add $i 1}}].Hex()
{{end}}	}
{{end}}
	// Extract data fields from event data
	if ctx.Event != nil && ctx.Event.Data != nil {
{{range .DataFields}}		if val, ok := ctx.Event.Data["{{.Name}}"]; ok {
{{if eq .SolidityType "address"}}			if addr, ok := val.(common.Address); ok {
				event.{{.GoName}} = addr.Hex()
			}
{{else if isBigInt .SolidityType}}			switch v := val.(type) {
			case *big.Int:
				event.{{.GoName}} = v.String()
			case string:
				event.{{.GoName}} = v
			}
{{else if eq .GoType "bool"}}			if boolVal, ok := val.(bool); ok {
				event.{{.GoName}} = boolVal
			}
{{else if eq .GoType "[]byte"}}			if bytesVal, ok := val.([]byte); ok {
				event.{{.GoName}} = bytesVal
			}
{{else}}			if strVal, ok := val.(string); ok {
				event.{{.GoName}} = strVal
			}
{{end}}		}
{{end}}	}

	// Save to database
	if err := ctx.DB.Create(event).Error; err != nil {
		return fmt.Errorf("saving {{.EventName}} event: %w", err)
	}

	return nil
}
